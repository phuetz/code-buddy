# RAG for Code (2023-2025)

Research findings on CodeRAG, repository-level context understanding, and dependency-aware retrieval.

---

## 1. Core CodeRAG Research

### CodeRAG-Bench (arXiv 2406.14497)
**Paper:** "CodeRAG-Bench: Can Retrieval Augment Code Generation?"
- **Link:** https://arxiv.org/abs/2406.14497
- **Purpose:** Comprehensive benchmark for retrieval-augmented code generation
- **Coverage:** Three categories - basic programming, open-domain, and repository-level problems
- **Data Sources:**
  - Competition solutions
  - Online tutorials
  - Library documentation
  - StackOverflow posts
  - GitHub repositories
- **Key Finding:** Current retrievers struggle with limited lexical overlap

### CodeRAG: Repository-Level Completion (arXiv 2509.16112)
**Paper:** "CodeRAG: Finding Relevant and Necessary Knowledge for Retrieval-Augmented Repository-Level Code Completion"
- **Link:** https://arxiv.org/abs/2509.16112
- **Core Components:**
  1. Log probability guided query construction
  2. Multi-path code retrieval
  3. Preference-aligned BestFit reranking
- **Problems Addressed:**
  - Inappropriate query construction
  - Single-path code retrieval limitations
  - Misalignment between retriever and LLM
- **Results:** Significantly outperforms SOTA on ReccEval and CCEval benchmarks

### CodeRAG: Supportive Code Retrieval on Bigraph (arXiv 2504.10046)
**Paper:** "CodeRAG: Supportive Code Retrieval on Bigraph for Real-World Code Generation"
- **Link:** https://arxiv.org/abs/2504.10046
- **Innovation:** Constructs requirement graph for repository
- **Graph Structure:**
  - Nodes: Functional descriptions of functions/classes
  - Edges: Relationships between requirements
- **Focus:** Real-world code generation with complex dependencies

---

## 2. Repository-Level Code Completion

### RepoCoder (EMNLP 2023, arXiv 2303.12570)
**Paper:** "RepoCoder: Repository-Level Code Completion Through Iterative Retrieval and Generation"
- **Link:** https://arxiv.org/abs/2303.12570
- **Architecture:** Iterative retrieval-generation pipeline
- **Components:**
  - Similarity-based retriever
  - Pre-trained code language model
- **Benchmark:** Introduced RepoEval dataset
- **Result:** 10%+ improvement over in-file completion baseline

### RepoFuse (arXiv 2402.14323)
**Paper:** "REPOFUSE: Repository-Level Code Completion with Fused Dual Context"
- **Link:** https://arxiv.org/abs/2402.14323
- **Innovation:** Fuses two context types:
  1. **Analogy Context:** Code analogies
  2. **Rationale Context:** In-depth semantic relationships
- **Technique:** Rank Truncated Generation (RTG) for context condensation
- **Results (CrossCodeEval):**
  - 40.90% to 59.75% increase in exact match accuracy
  - 26.8% enhancement in inference speed

### RepoGraph (arXiv 2410.14684)
**Paper:** "RepoGraph: Enhancing AI Software Engineering with Repository-level Code Graph"
- **Link:** https://arxiv.org/abs/2410.14684
- **Purpose:** Repository-wide navigation for AI software engineers
- **Evaluation:** Tested on SWE-bench, boosted performance of all systems
- **Extensibility:** Demonstrated on CrossCodeEval benchmark

---

## 3. Dependency-Aware Retrieval

### Graph Database Integration (arXiv 2408.03910)
**Paper:** "Bridging Large Language Models and Code Repositories via Code Graph Databases"
- **Link:** https://arxiv.org/html/2408.03910v1
- **Approach:** LLM agents with graph database interfaces
- **Capability:** Construct and execute graph queries
- **Benefit:** Precise, code structure-aware context retrieval

### Knowledge Graph for Code Generation (arXiv 2505.14394)
**Paper:** "Knowledge Graph Based Repository-Level Code Generation"
- **Link:** https://arxiv.org/html/2505.14394
- **Innovation:** Captures complex dependencies and usage patterns
- **Consideration:** Semantic context for downstream tasks

### MARIN: Hierarchical Dependency-Aware API Mitigation
**Paper:** "Towards Mitigating API Hallucination in Code Generated by LLMs with Hierarchical Dependency Aware"
- **Link:** https://dl.acm.org/doi/abs/10.1145/3696630.3728569
- **Problem:** API hallucination (invoking non-existent APIs)
- **Solution:** Two-phase approach:
  1. Hierarchical Dependency Mining (local + global)
  2. Dependency Constrained Decoding
- **Results:**
  - 67.52% decrease in Micro Hallucination Number
  - 73.56% decrease in Macro Hallucination Rate

---

## 4. Long-Range Dependency Handling

### Multi-Step Key Retrieval (arXiv 2407.21049)
**Paper:** "Evaluating Long Range Dependency Handling in Code Generation Models using Multi-Step Key Retrieval"
- **Link:** https://arxiv.org/abs/2407.21049
- **Key Findings:**
  - Performance degrades up to 2x when referencing later-defined functions
  - Sliding window attention struggles with cross-window references
  - Simple prompt modifications with call graph info improve performance up to 3x

### What to Retrieve? (arXiv 2503.20589)
**Paper:** "What to Retrieve for Effective Retrieval-Augmented Code Generation? An Empirical Study and Beyond"
- **Link:** https://arxiv.org/abs/2503.20589
- **Key Findings:**
  - In-context code and API info significantly enhance performance
  - Retrieved similar code often introduces noise
  - Noise can degrade results by up to 15%
- **Solution:** AllianceCoder with chain-of-thought prompting

---

## 5. Comprehensive Survey

### RACG Survey (arXiv 2510.04905)
**Paper:** "Retrieval-Augmented Code Generation: A Survey with Focus on Repository-Level Approaches"
- **Link:** https://arxiv.org/abs/2510.04905
- **Scope:** Comprehensive review of RACG research
- **Key Insights:**
  - Vector-based: Efficient and flexible, but lacks structural understanding
  - Graph-based: Better for architectural and dependency relationships
  - Graph-based excels at global consistency and cross-file reasoning

### Retrieval Paradigms
1. **Similarity-based:**
   - Term-based sparse retrievers
   - Embedding-based dense retrievers
2. **Structure-aware:**
   - Graph-based retrieval
   - Dependency graph integration
3. **Hybrid approaches:**
   - Combining multiple retrieval strategies

---

## Applications to CLI Tools

### Recommendations for Grok CLI

1. **Implement Multi-Path Retrieval (CodeRAG approach):**
   - Use log probability for query construction
   - Multiple retrieval paths for better coverage
   - Preference-aligned reranking

2. **Build Dependency Graph:**
   - Parse repository structure
   - Track import/export relationships
   - Map function call graphs

3. **Dual Context Fusion (RepoFuse approach):**
   - Analogy context: Similar code patterns
   - Rationale context: Semantic relationships
   - Use RTG for efficient prompt construction

4. **Mitigate Noise in Retrieval:**
   - Filter retrieved similar code carefully
   - Prioritize in-context code and API information
   - Use chain-of-thought for query decomposition

5. **Graph Database for Navigation:**
   - Enable graph queries for code structure
   - Support cross-file reference tracking
   - Provide call graph information in prompts

6. **Handle Long-Range Dependencies:**
   - Include call graph information in prompts
   - Prefer forward declarations when possible
   - Monitor performance with sliding window attention
